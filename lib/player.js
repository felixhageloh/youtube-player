// Generated by CoffeeScript 1.3.3
(function() {
  var callbacks, ytApi;

  callbacks = [];

  ytApi = $('<script>');

  ytApi.attr('src', "//www.youtube.com/iframe_api");

  $('script').parent().append(ytApi);

  this.onYouTubeIframeAPIReady = function() {
    var callback, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
      callback = callbacks[_i];
      _results.push(callback());
    }
    return _results;
  };

  this.Player = function(domEl, videoId, options) {
    var Slider, api, controls, destroy, init, newYTPlayer, onPlayerStateChange, onScrubberChange, onVolumeSliderChange, pauseButton, play, playButton, playbackPct, player, playerEl, playerReady, scrubber, scrubberEl, startUpdating, stopUpdating, thumbnailUrl, updateInterval, updateTimer, volumeEl, volumeSlider;
    if (options == null) {
      options = {};
    }
    domEl = $(domEl);
    domEl.html("    <div class='yt-player'></div>    <div class='controls'>      <div class='play'></div>      <div class='pause'></div>      <div class='scrubber slider'>        <div class='track'>          <div class='progress'></div>        </div>        <div class='knob'></div>      </div>      <div class='volume slider'>        <div class='track'>          <div class='progress'></div>        </div>        <div class='knob'>      </div></div>    </div>  ");
    controls = domEl.find('.controls');
    playerEl = domEl.find('.yt-player');
    playButton = controls.find('.play');
    pauseButton = controls.find('.pause');
    scrubberEl = controls.find('.scrubber');
    volumeEl = controls.find('.volume');
    player = null;
    scrubber = null;
    volumeSlider = null;
    play = false;
    destroy = false;
    api = {};
    updateTimer = null;
    updateInterval = 50;
    init = function() {
      newYTPlayer();
      domEl.css({
        'background-image': "url(" + (thumbnailUrl()) + ")"
      });
      return domEl.css({
        width: options.width,
        height: options.height
      });
    };
    playerReady = function(event) {
      var name, prop;
      player = event.target;
      if (destroy) {
        player.destroy();
        return;
      }
      playerEl = domEl.find('.yt-player');
      scrubber = Slider(scrubberEl, onScrubberChange);
      volumeSlider = Slider(volumeEl, onVolumeSliderChange);
      volumeSlider.moveTo(player.getVolume() / 100);
      for (name in player) {
        prop = player[name];
        api[name] = prop;
      }
      if (play) {
        player.playVideo();
      }
      play = false;
      return typeof callback === "function" ? callback(player) : void 0;
    };
    onScrubberChange = function(pct, released) {
      if (released == null) {
        released = false;
      }
      if (!player) {
        return;
      }
      return setTimeout(function() {
        return player.seekTo(pct.x * player.getDuration(), released);
      });
    };
    onVolumeSliderChange = function(pct, released) {
      if (released == null) {
        released = false;
      }
      if (!player) {
        return;
      }
      return player.setVolume(pct.x * 100);
    };
    api.resize = function(width, height) {
      domEl.css({
        width: width,
        height: height
      });
      playerEl.css({
        width: width,
        height: height
      });
      playerEl.attr('width', width).attr('height', height);
      return domEl.blur();
    };
    api.playVideo = function() {
      domEl.addClass('buffering');
      return play = true;
    };
    api.pauseVideo = function() {
      domEl.removeClass('buffering');
      return play = false;
    };
    api.destroy = function() {
      return destroy = true;
    };
    newYTPlayer = function() {
      options = $.extend({
        videoId: videoId,
        playerVars: {
          html5: 1,
          modestbranding: 1,
          showinfo: 0,
          wmode: 'transparent',
          controls: 0,
          iv_load_policy: 3,
          hd: 1
        },
        events: {
          'onReady': playerReady,
          'onStateChange': onPlayerStateChange
        }
      }, options);
      return new YT.Player(playerEl[0], options);
    };
    playbackPct = function() {
      if (!player) {
        return;
      }
      return player.getCurrentTime() / player.getDuration();
    };
    startUpdating = function() {
      return updateTimer = setInterval(function() {
        return scrubber.moveTo(playbackPct());
      }, updateInterval);
    };
    stopUpdating = function() {
      if (updateInterval) {
        return clearInterval(updateInterval);
      }
    };
    onPlayerStateChange = function(event) {
      if (event.data === YT.PlayerState.PLAYING) {
        domEl.addClass('playing');
        domEl.removeClass('paused').removeClass('buffering');
        scrubber.moveTo(playbackPct());
        return startUpdating();
      } else if (event.data === YT.PlayerState.BUFFERING) {
        return domEl.addClass('buffering');
      } else if (event.data === YT.PlayerState.PAUSED) {
        domEl.removeClass('playing').removeClass('buffering');
        domEl.addClass('paused');
        stopUpdating();
        return scrubber.moveTo(playbackPct());
      }
    };
    thumbnailUrl = function() {
      return "http://img.youtube.com/vi/" + videoId + "/0.jpg";
    };
    playButton.on('click', function() {
      return api.playVideo();
    });
    pauseButton.on('click', function() {
      return api.pauseVideo();
    });
    Slider = function(domEl, callback, options) {
      var constrain, currentPos, dragging, endDrag, knob, maxX, maxY, minX, minY, moveTo, positionPct, progressBar, render, startDrag, startPoint, startPos, track, trackClicked, trackRect, updateDrag, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      track = domEl.find('.track');
      knob = domEl.find('.knob');
      progressBar = domEl.find('.progress');
      startPoint = null;
      startPos = null;
      currentPos = {
        x: 0,
        y: 0
      };
      dragging = false;
      if ((_ref = options.dragX) == null) {
        options.dragX = true;
      }
      if ((_ref1 = options.dragY) == null) {
        options.dragY = false;
      }
      trackRect = track.offset();
      trackRect.width = track.width();
      trackRect.height = track.height();
      minX = 0;
      maxX = trackRect.width - knob.width();
      minY = 0;
      maxY = trackRect.height - knob.height();
      constrain = function(value, dimension) {
        if (dimension === 'x') {
          return Math.max(minX, Math.min(maxX, value));
        } else if (dimension === 'y') {
          return Math.max(minY, Math.min(maxY, value));
        }
      };
      startDrag = function(e) {
        startPoint = {
          x: e.pageX,
          y: e.pageY
        };
        startPos = {
          x: parseInt(knob.css('left')),
          y: parseInt(knob.css('top'))
        };
        if (isNaN(startPos.x)) {
          startPos.x = 0;
        }
        if (isNaN(startPos.y)) {
          startPos.y = 0;
        }
        currentPos = $.extend({}, startPos);
        dragging = true;
        $(document).on('mousemove', updateDrag);
        return $(document).on('mouseup', endDrag);
      };
      updateDrag = function(e) {
        var x, y;
        if (options.dragX) {
          x = e.pageX - startPoint.x;
          currentPos.x = constrain(startPos.x + x, 'x');
        }
        if (options.dragY) {
          y = constrain(e.pageY - startPoint.y, 'y');
          currentPos.x = constrain(startPos.y + y, 'y');
        }
        render();
        return callback(positionPct());
      };
      trackClicked = function(e) {
        if (dragging) {
          return;
        }
        if (options.dragX) {
          currentPos.x = e.pageX - trackRect.left;
        }
        if (options.dragY) {
          currentPos.y = e.pageY - trackRect.top;
        }
        render();
        return callback(positionPct(), true);
      };
      endDrag = function(e) {
        $(document).off('mousemove', updateDrag);
        $(document).off('mouseup', endDrag);
        callback(positionPct(), true);
        return setTimeout((function() {
          return dragging = false;
        }), 200);
      };
      positionPct = function() {
        return {
          x: currentPos.x / (maxX - minX),
          y: currentPos.y / (maxY - minY)
        };
      };
      render = function() {
        var scale;
        scale = {
          x: (options.dragX ? positionPct().x : 1),
          y: (options.dragY ? positionPct().y : 1)
        };
        progressBar.css({
          webkitTransform: "scale(" + scale.x + ", " + scale.y + ")"
        });
        return knob.css({
          left: options.dragX ? currentPos.x : null,
          top: options.dragY ? currentPos.y : null
        });
      };
      moveTo = function(pct) {
        if (dragging) {
          return;
        }
        if (options.dragX) {
          currentPos.x = pct * (maxX - minX);
        }
        if (options.dragY) {
          currentPos.y = pct * (maxY - minY);
        }
        return render();
      };
      knob.on('mousedown', startDrag);
      track.on('click', trackClicked);
      return {
        moveTo: moveTo
      };
    };
    if (typeof YT !== "undefined" && YT !== null) {
      init();
    } else {
      callbacks.push(init);
    }
    return api;
  };

}).call(this);
